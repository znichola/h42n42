(* This file was generated by Eliom-distillery. Feel free to use it, modify it,
   and redistribute it as you wish. *)

let%server application_name = "h42n42"
let%client application_name = Eliom_client.get_application_name ()

let%server () =
  Ocsipersist_settings.set_db_file "local/var/data/h42n42/h42n42_db"

(* Create a module for the application. See
   https://ocsigen.org/eliom/manual/clientserver-applications for more
   information. *)
module%shared App = Eliom_registration.App (struct
    let application_name = application_name
    let global_data_path = Some ["__global_data__"]
  end)

(* As the headers (stylesheets, etc) won't change, we ask Eliom not to update
   the <head> of the page when changing page. (This also avoids blinking when
   changing page in iOS). *)
let%client _ = Eliom_client.persist_document_head ()

(* Define a service for the [] or '/' or root path with a GET method *)
let%server main_service =
  Eliom_service.create ~path:(Eliom_service.Path [])
    ~meth:(Eliom_service.Get Eliom_parameter.unit) ()

(* Insert into the client client context the server defined value *)
let%client main_service = ~%main_service

[%%shared open Eliom_content]
[%%client open Js_of_ocaml]
[%%client open Js_of_ocaml_lwt]
[%%client open Js_of_ocaml.Dom_html]
[%%client open Html.D]
[%%client open Lwt.Syntax]


(* --------------- *)
(* World COMPONENT *)
(* --------------- *)

(* World component *)
let%client world_component () =
  Html.D.div
    ~a:[Html.D.a_class ["world"]]
    [ Html.D.div ~a:[Html.D.a_class ["river"]] []
    ; Html.D.div ~a:[Html.D.a_class ["grass"]] []
    ; Html.D.div ~a:[Html.D.a_class ["hospital"]] []
    ]


(* ------------- *)
(* HUB COMPONENT *)
(* ------------- *)

(* Get stats function *)
let%client get_stats () =
  let width = window##.innerWidth in
  let height = window##.innerHeight in
  let total_parts = 6 in (* 1 + 4 + 1 *)
  let part_height = float_of_int height /. float_of_int total_parts in
  (width, height, part_height)

let%client get_section (part_height, y_height) = 
  let river_end = part_height in
  let grass_end = part_height +. (4.0 *. part_height) in
  let section = 
    if y_height < river_end then "River"
    else if y_height < grass_end then "Grass"
    else "Hospital"
  in
  section

(* HUD component *)
let%client hud_component () =
  let mouse_x = ref 0 in
  let mouse_y = ref 0 in
  let creep_count = ref 0 in
  let stats_container = div ~a:[a_class ["hud-stats"]] [] in

  let update_stats () =
    let (width, height, part_height) = get_stats () in
    let current_section = get_section (part_height, float_of_int !mouse_y) in
    Eliom_content.Html.Manip.replaceChildren stats_container
      [ div [txt (Printf.sprintf "Resolution: %dx%d" width height)]
      ; div [txt (Printf.sprintf "Mouse: (%d, %d)" !mouse_x !mouse_y)]
      ; div [txt (Printf.sprintf "Inside: %s" current_section)]
      ; div [txt (Printf.sprintf "Creeps: %d" !creep_count)]
      ]
  in

  (* Initial update *)
  update_stats ();

  (* Add resize event listener *)
  let _ = Dom_html.addEventListener 
    window 
    (Dom_html.Event.resize)
    (Dom_html.handler (fun _ -> update_stats (); Js._true))
    Js._false
  in

  (* Add mousemove event listener *)
  let _ = Dom_html.addEventListener 
    window 
    (Dom_html.Event.mousemove)
    (Dom_html.handler (fun evt -> 
      mouse_x := evt##.clientX;
      mouse_y := evt##.clientY;
      update_stats (); 
      Js._true))
    Js._false
  in

  div
    ~a:[a_class ["hud"]]
    [ div
        ~a:[a_class ["hud-content"]]
        [ div [txt "simulation running"]
        ; stats_container
        ]
    ], creep_count, update_stats


(* --------------- *)
(* CREEP COMPONENT *)
(* --------------- *)

[%%client
type creep_state = {
  mutable x: float;
  mutable y: float;
  mutable vx: float;
  mutable vy: float;
  _id: int;
  element: Html_types.div Html.elt;
}
]

(* Global counter for unique IDs *)
let%client next_creep_id = ref 0

(* Generate a unique ID *)
let%client generate_unique_id () =
  let id = !next_creep_id in
  next_creep_id := !next_creep_id + 1;
  id

(* Create a single creep *)
let%client create_creep id start_x start_y =
  let creep_div = div ~a:[a_class ["creep"]; a_id (Printf.sprintf "creep-%d" id)] [txt "üêõ"] in
  let creep = {
    x = start_x;
    y = start_y;
    vx = Random.float 2.0 -. 1.0;  (* Random velocity between -1 and 1 *)
    vy = Random.float 2.0 -. 1.0;
    _id = id;
    element = creep_div;
  } in
  creep

(* Update creep position *)
let%client update_creep_position creep =
  let (width, height, _) = get_stats () in
  let width_f = float_of_int width in
  let height_f = float_of_int height in

  (* Update position *)
  creep.x <- creep.x +. creep.vx;
  creep.y <- creep.y +. creep.vy;

  (* Bounce off walls *)
  if creep.x <= 0.0 || creep.x >= width_f -. 20.0 then
    creep.vx <- -.creep.vx;
  if creep.y <= 0.0 || creep.y >= height_f -. 20.0 then
    creep.vy <- -.creep.vy;

  (* Clamp position *)
  creep.x <- max 0.0 (min (width_f -. 20.0) creep.x);
  creep.y <- max 0.0 (min (height_f -. 20.0) creep.y);

  (* Update DOM element style *)
  let creep_element = Eliom_content.Html.To_dom.of_div creep.element in
  creep_element##.style##.left := Js.string (Printf.sprintf "%.2fpx" creep.x);
  creep_element##.style##.top := Js.string (Printf.sprintf "%.2fpx" creep.y)

(* Simulation loop for a single creep using Lwt *)
let%client rec simulate_creep creep =
  let* () = Lwt_js.sleep 0.016 in (* ~60 FPS *)
  update_creep_position creep;
  simulate_creep creep

(* Creeps container component *)
let%client creeps_component creep_count_ref update_stats_fn =
  let container = div ~a:[a_class ["creeps-container"]] [] in
  let creeps = ref [] in

  (* Spawn a new creep *)
  let spawn_creep () =
    let (width, height, _) = get_stats () in
    let id = generate_unique_id () in
    let start_x = Random.float (float_of_int width -. 20.0) in
    let start_y = Random.float (float_of_int height -. 20.0) in
    let creep = create_creep id start_x start_y in

    (* Add creep to container *)
    Eliom_content.Html.Manip.appendChild container creep.element;
    creeps := creep :: !creeps;
    creep_count_ref := List.length !creeps;
    update_stats_fn ();

    (* Start simulation for this creep *)
    let _ = simulate_creep creep in
    ()
  in

  (* Spawn initial creeps *)
  for _i = 0 to 4 do
    spawn_creep ()
  done;

  (* Spawn new creeps periodically *)
  let rec spawn_loop () =
    let* () = Lwt_js.sleep 3.0 in (* Spawn every 3 seconds *)
    spawn_creep ();
    spawn_loop ()
  in
  let _ = spawn_loop () in

  container


(* -------------- *)
(* Main COMPONENT *)
(* -------------- *)

(* Register and implement handlers and setup the index layout*)
let%shared () =
  App.register ~service:main_service (fun () () ->
    Lwt.return
      Html.F.(
        html
          (head
             (title (txt "h42n42"))
             [ css_link
                 ~uri:
                   (make_uri
                      ~service:(Eliom_service.static_dir ())
                      ["css"; "h42n42.css"])
                 () ])
          (body 
            [ Html.C.node [%client world_component ()]
            ; Html.C.node [%client 
                let (hud, creep_count, update_stats) = hud_component () in
                let creeps = creeps_component creep_count update_stats in
                div [hud; creeps]
              ]
            ])))
